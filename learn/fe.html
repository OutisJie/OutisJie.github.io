<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | 远书</title>
    <meta name="description" content="武杰的博客">
    <link rel="icon" href="/farbook/img/favicon.ico">
    
    <link rel="preload" href="/farbook/assets/css/0.styles.d848cb78.css" as="style"><link rel="preload" href="/farbook/assets/js/app.94912acd.js" as="script"><link rel="preload" href="/farbook/assets/js/6.8b4827df.js" as="script"><link rel="prefetch" href="/farbook/assets/js/10.f3a1e354.js"><link rel="prefetch" href="/farbook/assets/js/11.e1fa28ed.js"><link rel="prefetch" href="/farbook/assets/js/12.003b51f7.js"><link rel="prefetch" href="/farbook/assets/js/13.879de09e.js"><link rel="prefetch" href="/farbook/assets/js/2.ce84c41e.js"><link rel="prefetch" href="/farbook/assets/js/3.9ed61a99.js"><link rel="prefetch" href="/farbook/assets/js/4.f7536711.js"><link rel="prefetch" href="/farbook/assets/js/5.c8ad67f6.js"><link rel="prefetch" href="/farbook/assets/js/7.e75f3bb5.js"><link rel="prefetch" href="/farbook/assets/js/8.b2ccaa1f.js"><link rel="prefetch" href="/farbook/assets/js/9.e31bf60d.js">
    <link rel="stylesheet" href="/farbook/assets/css/0.styles.d848cb78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/farbook/" class="home-link router-link-active"><!----> <span class="site-name">远书</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/farbook/" class="nav-link">主页</a></div><div class="nav-item"><a href="/farbook/learn/" class="nav-link router-link-active">学习</a></div><div class="nav-item"><a href="/farbook/handnote/" class="nav-link">手记</a></div><div class="nav-item"><a href="/farbook/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/OutisJie/farbook" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/farbook/" class="nav-link">主页</a></div><div class="nav-item"><a href="/farbook/learn/" class="nav-link router-link-active">学习</a></div><div class="nav-item"><a href="/farbook/handnote/" class="nav-link">手记</a></div><div class="nav-item"><a href="/farbook/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/OutisJie/farbook" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/farbook/learn/" class="sidebar-link">HTML</a></li><li><a href="/farbook/learn/fe.html" class="active sidebar-link">JS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/farbook/learn/fe.html#javascript-原型链" class="sidebar-link">JavaScript 原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/farbook/learn/fe.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/farbook/learn/fe.html#prototype" class="sidebar-link">Prototype</a></li><li class="sidebar-sub-header"><a href="/farbook/learn/fe.html#proto" class="sidebar-link">__proto__</a></li><li class="sidebar-sub-header"><a href="/farbook/learn/fe.html#new-的过程" class="sidebar-link">new 的过程</a></li><li class="sidebar-sub-header"><a href="/farbook/learn/fe.html#function-的特殊性-function-proto-function-prototype" class="sidebar-link">Function 的特殊性 Function.__proto__ === Function.prototype</a></li><li class="sidebar-sub-header"><a href="/farbook/learn/fe.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></li><li><a href="/farbook/learn/css.html" class="sidebar-link">CSS</a></li><li><a href="/farbook/learn/browser.html" class="sidebar-link">浏览器</a></li><li><a href="/farbook/learn/os.html" class="sidebar-link">操作系统</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="js"><a href="#js" aria-hidden="true" class="header-anchor">#</a> JS</h1> <p>我觉得 JS（ES6）是一门非常好的语言，不接受反驳 😠。我之所以会喜欢上 JS 是因为它的语法和表现力，它不是最优秀的支持 OO（面向对象）的语言，也不是最优秀的 FP（函数式编程）语言，但我觉得它在两方面兼顾的非常好。</p> <p>MDN+项目是我主要的学习方式，感觉在 MDN 上看到的都是精华，很吸引人。我最开始也看犀牛书、JS 高级程序设计啥的，但是看的我头疼，一上来讲的都是基础，后面才讲到精华部分，我一个有编程基础的人 🐶🐶 实在耐不住性子，而且在抄别人的代码（说自己从来没抄过代码的人出来挨打 🤨）的时候发现别人都有更新的用法，书的更新速度绝对比不了 MDN 的，所以 MDN 无敌！🌝</p> <h2 id="javascript-原型链"><a href="#javascript-原型链" aria-hidden="true" class="header-anchor">#</a> JavaScript 原型链</h2> <p>JS 非常特别，有好几种继承方式，每种方式都有各自的优点，其中原型继承是极具表现力的 OO 方式，非常灵活。先来看看 JS 中的原型链：</p> <h3 id="原型链"><a href="#原型链" aria-hidden="true" class="header-anchor">#</a> 原型链</h3> <p>首先拿出一张图劝退 🤪：</p> <p><img src="/farbook/assets/img/prototype.6cb874e1.png" alt="img"></p> <p>奶奶的，我看你就是在  为难我胖虎 😭，感觉比我当初学小公举的《一口气全念对》还难，第一次见到的时候，不，我第一次直接跳过了这张图 🌚，当时真的看不懂，我是看了好多遍才搞明白的， 我慢慢讲，争取讲清楚。</p> <hr> <p>乍一看这张图，杂乱无章，其实不是的，这图主要是三行三列， 从左往右三列依次是:</p> <p><strong>new（ 实例）-&gt; function（构造函数) -&gt; prototypes（原型）</strong></p> <p>这是一个是逐渐深入的、渐进的过程、可以比喻成 :</p> <p><strong>new（人）-&gt; function（成长过程，包括出生、学习、工作、恋爱等等）-&gt; 复读机（本质）</strong></p> <p>是不是很好理解，每一个人，经过社会的洗礼都变得独一无二，但无论是谁，其本质都是复读机 🧐。同样，每一个实例出来的对象，是要经过构造函数的雕琢的，他们的本质都是 <code>prototypes</code>。而这里的箭头就是图中的<code>__proto__</code>。举一反三，我们再举个例子:</p> <p><strong>new (炮姐/gakki/十元/飞鸟/桥本) -&gt; function () -&gt; 老婆（都是我的，拔刀吧）</strong></p> <p>进一步理解，某个实例 A 的原型可不可以是别的实例 B 吗？当然可以，只需要通过构造函数就能自己指定实例的原型，我不做人啦！JOJO ～。其实，就算你修改了 A 的 <code>proto</code> 的指向，使其指向 B，但是 B 的 <code>proto</code> 没有变，你沿着这条路往上走，最终肯定还是复读机，这样一条链路就是<strong>原型链</strong>了。</p> <p>从上往下三行其实是并行的关系，不可能只有一个最原始的原型，女娲当年造人都有男女之分，JS 也一样，JS 有 <strong>Object.prototype</strong> 和 <strong>Function.prototype</strong> 两个原始对象，它们由引擎生成，分别对应 <strong>function Object()</strong> 和 <strong>function Function()</strong> 两个构造函数， 来构建它们的子类。</p> <h3 id="prototype"><a href="#prototype" aria-hidden="true" class="header-anchor">#</a> Prototype</h3> <p>有且仅有函数有这个属性，这是一个显示原型属性，基本上所有函数都有，但有一个例外：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 用这个方法创建的函数是不具备prototype属性的, Function.prototype.bind()本身就指向原型。</span>
<span class="token keyword">let</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><h4 id="prototype-是怎么产生的："><a href="#prototype-是怎么产生的：" aria-hidden="true" class="header-anchor">#</a> prototype 是怎么产生的：</h4> <p>当我们声明一个函数时，该属性就被自动创建了，而且该熟悉的值是一个对象，也就是原型。原型只有一个显示属性 <code>constructor</code> ，并且指向构造函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { constructor: ƒ (), __proto__: Object }，这个就是原型</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ƒ (){}，这个就是函数foo</span>

<span class="token comment">// 匿名函数不太直观，用有名函数试试</span>
<span class="token keyword">function</span> <span class="token function">goo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>goo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { constructor: ƒ goo(), __proto__: Object }</span>
</code></pre></div><h4 id="constructor"><a href="#constructor" aria-hidden="true" class="header-anchor">#</a> constructor</h4> <p><code>constructor</code> 是一个公有且不可枚举的属性。一旦我们改变了函数的 <code>prototype</code> ，那么新对象就没有这个属性了（当然可以通过原型链取到 <code>constructor</code>）。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>foo<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><p>这个属性在大多数情况下都是没有用的，但是，我上面说过构造函数决定了对象实例长成什么样子。如果你想自定义一下某个对象，你可以不用直接修改 <code>constructor</code> 的代码，而是用<code>xx.constructor.method</code>来扩展</p> <h3 id="proto"><a href="#proto" aria-hidden="true" class="header-anchor">#</a> __proto__</h3> <p>这是每个对象都有的隐式原型属性，指向了<strong>创建该对象的构造函数的原型</strong>。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</p> <p>因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 <code>__proto__</code> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。</p> <p>说到这，有几个特殊情况需要说明:</p> <ol><li><p><strong><code>Object.prototype.__proto__ === null</code></strong></p> <p>Object.prototype 是原型，自然没有 proto，你再循环向上遍历原型链的时候，null 就代表到头了</p></li> <li><p><strong><code>Object.__proto__ === Function.prototype</code></strong></p> <p>这个上面的图也有一个箭头，因为 Object 是 Function 创建的，那么对象的<code>__proto__</code>要指向创建它的构造函数的原型</p></li> <li><p><strong><code>Function 的特殊性 Function.__proto__ === Function.prototype</code></strong></p> <p>对于对象来说，<code>xx.__proto__.constructor</code>是该对象的构造函数，<code>xx.__proto__</code>指向其构造函数的原型，但是在图中，我们看到<code>Function.__proto__ === Function.prototype</code>，这不就代表 Function 的构造函数是它自己吗，难道是它自己创建了自己？？答案肯定是否定的，我们稍后讨论。</p></li> <li><p><strong>Object.prototype 和 Function.prototype 是由引擎构建的</strong></p></li></ol> <h4 id="proto-是怎么产生的"><a href="#proto-是怎么产生的" aria-hidden="true" class="header-anchor">#</a> __proto__是怎么产生的</h4> <p>当我们 new 一个对象时，实例出来的对象就有了__proto__属性。</p> <h3 id="new-的过程"><a href="#new-的过程" aria-hidden="true" class="header-anchor">#</a> new 的过程</h3> <p>除了 Object.prototype 和 Function.prototype 这两个特殊对象，其余都是通过构造器 new 出来的。先来看看 new 的步骤 :</p> <ol><li>新生成一个对象</li> <li>将该中间对象的原型<code>__proto__</code>指向构造函数的原型<code>prototype</code></li> <li>将构造函数的 this，绑定到中间对象，并调用</li> <li>返回该中间对象</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 接收一个入参constructor, 以及构造函数所需的入参</span>
  <span class="token comment">// 创建一个新对象</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 取出参数中第一个参数</span>
  <span class="token keyword">let</span> Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 将obj的原型指向构造函数的原型，</span>
  <span class="token comment">// 这样obj可以访问构造函数的原型的属性，实现继承</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

  <span class="token comment">// 改变构造函数的this的指向，使其指向obj,</span>
  <span class="token comment">// 此时obj也可以访问构造函数中的属性了</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> Constructor<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 返回</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于实例对象来说，都是通过 new 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p> <p>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，特别是当你自己定义了一个 <code>Object</code> 对象的时候，但是你使用字面量的方式就没这个问题。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// function其实是语法糖，内部等同new Function()</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 字面量内部也是使用了new Object()</span>
<span class="token comment">// 但不需要沿着作用域链找到Object</span>
</code></pre></div><h3 id="function-的特殊性-function-proto-function-prototype"><a href="#function-的特殊性-function-proto-function-prototype" aria-hidden="true" class="header-anchor">#</a> <code>Function 的特殊性 Function.__proto__ === Function.prototype</code></h3> <p>上面讨论到是不是 Function 自己创建了自己的问题，答案肯定是否，为什么呢？</p> <p>先看 <code>Object.prototype</code> ，从图中我们可以看出，所有对象可以通过原型链最终找到<code>Object.prototype</code>，虽然<code>Object.prototype</code>是一个对象，但它却是由引擎自己创建的。所以可以这样说<strong>所有的实例都是对象，但不是所有对象都是实例</strong></p> <p>再看<code>Function.prototype</code>，我们试着将其打印出来看下，可以发现这是一个函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  f() {[native code]}</span>
</code></pre></div><p>我们知道函数都是通过 <code>new Function()</code> 生成的，难道 <code>Function.prototype</code> 也是通过 <code>new Function()</code> 产生的吗？答案也是否定的，这个函数也是引擎自己创建的。首先引擎创建了 <code>Object.prototype</code> ，然后创建了 <code>Function.prototype</code> ，并且通过 <code>__proto__</code> 将两者联系了起来。这里也很好的解释了上面的一个问题，为什么 <code>let fun = Function.prototype.bind()</code> 没有 <code>prototype</code> 属性。因为 <code>Function.prototype</code> 是引擎创建出来的对象，引擎认为不需要给这个对象添加 <code>prototype</code> 属性。</p> <p><strong>所以又可以的出一条结论，并不是所有函数都是<code>new Function()</code>创建的</strong></p> <p>现在可以来解释<code>Function.__proto__ === Function.prototype</code>这个问题了，是先有的 <code>Function.prototype</code> 以后才有了<code>function Function()</code>。最好的解释就是，其他所有的构造函数都能够通过原型链找到<code>Function.prototype</code>，为了避免混乱，就将<code>function Function()</code> 的 <code>__proto__</code> 联系到了 <code>Function.prototype</code> 上。</p> <h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>对象都是通过函数创建的，函数是对象，剪不断，理还乱，是离愁，别是一番滋味在心头。🤪</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/farbook/learn/" class="prev router-link-active">
          HTML
        </a></span> <span class="next"><a href="/farbook/learn/css.html">
          CSS
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/farbook/assets/js/app.94912acd.js" defer></script><script src="/farbook/assets/js/6.8b4827df.js" defer></script>
  </body>
</html>
