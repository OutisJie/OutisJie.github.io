(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{183:function(t,n,s){t.exports=s.p+"assets/img/prototype.6cb874e1.png"},190:function(t,n,s){"use strict";s.r(n);var a=[function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js","aria-hidden":"true"}},[t._v("#")]),t._v(" JS")]),t._v(" "),a("p",[t._v("我觉得 JS（ES6）是一门非常好的语言，不接受反驳 😠。我之所以会喜欢上 JS 是因为它的语法和表现力，它不是最优秀的支持 OO（面向对象）的语言，也不是最优秀的 FP（函数式编程）语言，但我觉得它在两方面兼顾的非常好。")]),t._v(" "),a("p",[t._v("MDN+项目是我主要的学习方式，感觉在 MDN 上看到的都是精华，很吸引人。我最开始也看犀牛书、JS 高级程序设计啥的，但是看的我头疼，一上来讲的都是基础，后面才讲到精华部分，我一个有编程基础的人 🐶🐶 实在耐不住性子，而且在抄别人的代码（说自己从来没抄过代码的人出来挨打 🤨）的时候发现别人都有更新的用法，书的更新速度绝对比不了 MDN 的，所以 MDN 无敌！🌝")]),t._v(" "),a("h2",{attrs:{id:"javascript-原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-原型链","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript 原型链")]),t._v(" "),a("p",[t._v("JS 非常特别，有好几种继承方式，每种方式都有各自的优点，其中原型继承是极具表现力的 OO 方式，非常灵活。先来看看 JS 中的原型链：")]),t._v(" "),a("h3",{attrs:{id:"原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链","aria-hidden":"true"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),a("p",[t._v("首先拿出一张图劝退 🤪：")]),t._v(" "),a("p",[a("img",{attrs:{src:s(183),alt:"img"}})]),t._v(" "),a("p",[t._v("奶奶的，我看你就是在 \b 为难我胖虎 \b😭，感觉比我当初学小公举的《一口气全念对》还难，第一次见到的时候，不，我第一次直接跳过了这张图 🌚，当时真的看不懂，我是看了好多遍才搞明白的，\b 我慢慢讲，争取讲清楚。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("乍一看这张图，杂乱无章，其实不是的，这图主要是三行三列，\b\b 从左往右三列依次是:")]),t._v(" "),a("p",[a("strong",[t._v("new（\b 实例）->\b\b function（构造函数) -> prototypes（原型）")])]),t._v(" "),a("p",[t._v("这是一个是逐渐深入的、渐进的过程、可以比喻成 \b:")]),t._v(" "),a("p",[a("strong",[t._v("new（人）-> function（成长过程，包括出生、学习、工作、恋爱等等）-> 复读机（本质）")])]),t._v(" "),a("p",[t._v("是不是很好理解，每一个人，经过社会的洗礼都变得独一无二，但无论是谁，其本质都是复读机 🧐。同样，每一个实例出来的对象，是要经过构造函数的雕琢的，他们的本质都是 "),a("code",[t._v("prototypes")]),t._v("。而这里的箭头就是图中的"),a("code",[t._v("__proto__")]),t._v("。举一反三，我们再举个例子:")]),t._v(" "),a("p",[a("strong",[t._v("new (炮姐/gakki/十元/飞鸟/桥本) -> function () -> 老婆（都是我的，拔刀吧）")])]),t._v(" "),a("p",[t._v("进一步理解，某个实例 A 的原型可不可以是别的实例 B 吗？当然可以，只需要通过构造函数就能自己指定实例的原型，我不做人啦！JOJO ～。其实，就算你修改了 A 的 "),a("code",[t._v("proto")]),t._v(" 的指向，使其指向 B，但是 B 的 "),a("code",[t._v("proto")]),t._v(" 没有变，你沿着这条路往上走，最终肯定还是复读机，这样一条链路就是"),a("strong",[t._v("原型链")]),t._v("了。")]),t._v(" "),a("p",[t._v("从上往下三行其实是并行的关系，不可能只有一个最原始的原型，女娲当年造人都有男女之分，JS 也一样，JS 有 "),a("strong",[t._v("Object.prototype")]),t._v(" 和 "),a("strong",[t._v("Function.prototype")]),t._v(" 两个原始对象，它们由引擎生成，分别对应 "),a("strong",[t._v("function Object()")]),t._v(" 和 "),a("strong",[t._v("function Function()")]),t._v(" 两个构造函数， 来构建它们的子类。")]),t._v(" "),a("h3",{attrs:{id:"prototype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prototype","aria-hidden":"true"}},[t._v("#")]),t._v(" Prototype")]),t._v(" "),a("p",[t._v("有且仅有函数有这个属性，这是一个显示原型属性，基本上所有函数都有，但有一个例外：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用这个方法创建的函数是不具备prototype属性的, Function.prototype.bind()本身就指向原型。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("fun")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Function"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fun"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\n")])])]),a("h4",{attrs:{id:"prototype-是怎么产生的："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prototype-是怎么产生的：","aria-hidden":"true"}},[t._v("#")]),t._v(" prototype 是怎么产生的：")]),t._v(" "),a("p",[t._v("当我们声明一个函数时，该属性就被自动创建了，而且该熟悉的值是一个对象，也就是原型。原型只有一个显示属性 "),a("code",[t._v("constructor")]),t._v(" ，并且指向构造函数")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("foo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { constructor: ƒ (), __proto__: Object }，这个就是原型")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ƒ (){}，这个就是函数foo")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匿名函数不太直观，用有名函数试试")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("goo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("goo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { constructor: ƒ goo(), __proto__: Object }")]),t._v("\n")])])]),a("h4",{attrs:{id:"constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor","aria-hidden":"true"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),a("p",[a("code",[t._v("constructor")]),t._v(" 是一个公有且不可枚举的属性。一旦我们改变了函数的 "),a("code",[t._v("prototype")]),t._v(" ，那么新对象就没有这个属性了（当然可以通过原型链取到 "),a("code",[t._v("constructor")]),t._v("）。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\n")])])]),a("p",[t._v("这个属性在大多数情况下都是没有用的，但是，我上面说过构造函数决定了对象实例长成什么样子。如果你想自定义一下某个对象，你可以不用直接修改 "),a("code",[t._v("constructor")]),t._v(" 的代码，而是用"),a("code",[t._v("xx.constructor.method")]),t._v("来扩展")]),t._v(" "),a("h3",{attrs:{id:"proto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proto","aria-hidden":"true"}},[t._v("#")]),t._v(" __proto__")]),t._v(" "),a("p",[t._v("这是每个对象都有的隐式原型属性，指向了"),a("strong",[t._v("创建该对象的构造函数的原型")]),t._v("。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 "),a("code",[t._v("_proto_")]),t._v(" 来访问。")]),t._v(" "),a("p",[t._v("因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 "),a("code",[t._v("__proto__")]),t._v(" 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。")]),t._v(" "),a("p",[t._v("说到这，有几个特殊情况需要说明:")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[a("code",[t._v("Object.prototype.__proto__ === null")])])]),t._v(" "),a("p",[t._v("Object.prototype 是原型，自然没有 proto，你再循环向上遍历原型链的时候，null 就代表到头了")])]),t._v(" "),a("li",[a("p",[a("strong",[a("code",[t._v("Object.__proto__ === Function.prototype")])])]),t._v(" "),a("p",[t._v("这个上面的图也有一个箭头，因为 Object 是 Function 创建的，那么对象的"),a("code",[t._v("__proto__")]),t._v("要指向创建它的构造函数的原型")])]),t._v(" "),a("li",[a("p",[a("strong",[a("code",[t._v("Function 的特殊性 Function.__proto__ === Function.prototype")])])]),t._v(" "),a("p",[t._v("对于对象来说，"),a("code",[t._v("xx.__proto__.constructor")]),t._v("是该对象的构造函数，"),a("code",[t._v("xx.__proto__")]),t._v("指向其构造函数的原型，但是在图中，我们看到"),a("code",[t._v("Function.__proto__ === Function.prototype")]),t._v("，这不就代表 Function 的构造函数是它自己吗，难道是它自己创建了自己？？答案肯定是否定的，我们稍后讨论。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Object.prototype 和 Function.prototype 是由引擎构建的")])])])]),t._v(" "),a("h4",{attrs:{id:"proto-是怎么产生的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proto-是怎么产生的","aria-hidden":"true"}},[t._v("#")]),t._v(" __proto__是怎么产生的")]),t._v(" "),a("p",[t._v("当我们 new 一个对象时，实例出来的对象就有了__proto__属性。")]),t._v(" "),a("h3",{attrs:{id:"new-的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-的过程","aria-hidden":"true"}},[t._v("#")]),t._v(" new 的过程")]),t._v(" "),a("p",[t._v("除了 Object.prototype 和 Function.prototype 这两个特殊对象，其余都是通过构造器 new 出来的。先来看看 new 的步骤 :")]),t._v(" "),a("ol",[a("li",[t._v("新生成一个对象")]),t._v(" "),a("li",[t._v("将该中间对象的原型"),a("code",[t._v("__proto__")]),t._v("指向构造函数的原型"),a("code",[t._v("prototype")])]),t._v(" "),a("li",[t._v("将构造函数的 this，绑定到中间对象，并调用")]),t._v(" "),a("li",[t._v("返回该中间对象")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 接收一个入参constructor, 以及构造函数所需的入参")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个新对象")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 取出参数中第一个参数")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" Constructor "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shift"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将obj的原型指向构造函数的原型，")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这样obj可以访问构造函数的原型的属性，实现继承")]),t._v("\n  obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Constructor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 改变构造函数的this的指向，使其指向obj,")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此时obj也可以访问构造函数中的属性了")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Constructor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"object"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("对于实例对象来说，都是通过 new 产生的，无论是 "),a("code",[t._v("function Foo()")]),t._v(" 还是 "),a("code",[t._v("let a = { b : 1 }")]),t._v(" 。")]),t._v(" "),a("p",[t._v("对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 "),a("code",[t._v("new Object()")]),t._v(" 的方式创建对象需要通过作用域链一层层找到 "),a("code",[t._v("Object")]),t._v("，特别是当你自己定义了一个 "),a("code",[t._v("Object")]),t._v(" 对象的时候，但是你使用字面量的方式就没这个问题。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function其实是语法糖，内部等同new Function()")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 字面量内部也是使用了new Object()")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但不需要沿着作用域链找到Object")]),t._v("\n")])])]),a("h3",{attrs:{id:"function-的特殊性-function-proto-function-prototype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-的特殊性-function-proto-function-prototype","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Function 的特殊性 Function.__proto__ === Function.prototype")])]),t._v(" "),a("p",[t._v("上面讨论到是不是 Function 自己创建了自己的问题，答案肯定是否，为什么呢？")]),t._v(" "),a("p",[t._v("先看 "),a("code",[t._v("Object.prototype")]),t._v(" ，从图中我们可以看出，所有对象可以通过原型链最终找到"),a("code",[t._v("Object.prototype")]),t._v("，虽然"),a("code",[t._v("Object.prototype")]),t._v("是一个对象，但它却是由引擎自己创建的。所以可以这样说"),a("strong",[t._v("所有的实例都是对象，但不是所有对象都是实例")])]),t._v(" "),a("p",[t._v("再看"),a("code",[t._v("Function.prototype")]),t._v("，我们试着将其打印出来看下，可以发现这是一个函数。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Function"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  f() {[native code]}")]),t._v("\n")])])]),a("p",[t._v("我们知道函数都是通过 "),a("code",[t._v("new Function()")]),t._v(" 生成的，难道 "),a("code",[t._v("Function.prototype")]),t._v(" 也是通过 "),a("code",[t._v("new Function()")]),t._v(" 产生的吗？答案也是否定的，这个函数也是引擎自己创建的。首先引擎创建了 "),a("code",[t._v("Object.prototype")]),t._v(" ，然后创建了 "),a("code",[t._v("Function.prototype")]),t._v(" ，并且通过 "),a("code",[t._v("__proto__")]),t._v(" 将两者联系了起来。这里也很好的解释了上面的一个问题，为什么 "),a("code",[t._v("let fun = Function.prototype.bind()")]),t._v(" 没有 "),a("code",[t._v("prototype")]),t._v(" 属性。因为 "),a("code",[t._v("Function.prototype")]),t._v(" 是引擎创建出来的对象，引擎认为不需要给这个对象添加 "),a("code",[t._v("prototype")]),t._v(" 属性。")]),t._v(" "),a("p",[a("strong",[t._v("所以又可以的出一条结论，并不是所有函数都是"),a("code",[t._v("new Function()")]),t._v("创建的")])]),t._v(" "),a("p",[t._v("现在可以来解释"),a("code",[t._v("Function.__proto__ === Function.prototype")]),t._v("这个问题了，是先有的 "),a("code",[t._v("Function.prototype")]),t._v(" 以后才有了"),a("code",[t._v("function Function()")]),t._v("。最好的解释就是，其他所有的构造函数都能够通过原型链找到"),a("code",[t._v("Function.prototype")]),t._v("，为了避免混乱，就将"),a("code",[t._v("function Function()")]),t._v(" 的 "),a("code",[t._v("__proto__")]),t._v(" 联系到了 "),a("code",[t._v("Function.prototype")]),t._v(" 上。")]),t._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("对象都是通过函数创建的，函数是对象，剪不断，理还乱，是离愁，别是一番滋味在心头。🤪")])])}],o=s(0),e=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},a,!1,null,null,null);e.options.__file="fe.md";n.default=e.exports}}]);